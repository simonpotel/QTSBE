import discord
import requests
import json
import tempfile
import os
import plotly.io as pio
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from discord_bot.embeds import reply_embed, create_embed

# Chart colors dictionary
chart_colors = {
    "Price": "#6c7386",
    "MA_100": "#B8336A",
    "MA_40": "#FF9B42",
    "MA_20": "#F4D35E",
    "Test": "#C73E1D",
    "RSI": "#9AB87A",
    "EMA": "#F0A7A0",
    "EMA_MACD": "#F0A7A0",
    "MACD": "#5E4AE3",
    "Normalize_MACD": "#947BD3",
    "Bollinger_Lower": "#A682FF",
    "Bollinger_Rolling": "#A682FF",
    "Bollinger_Upper": "#A682FF",
}

async def fetch_and_send_data(message, data_file, strategy):
    """
    Function to fetch and send data to discord
    """
    reply_msg = [None, f"Analyse: {data_file}, {strategy}", discord.Color.green()]
    reply_msg[0] = await reply_embed(
        message=message, 
        title=reply_msg[1],
        description=f"🔎 Searching",
        color=reply_msg[2]
    )
    
    try:
        await reply_msg[0].edit(embed=create_embed(
            title=reply_msg[1], 
            description="🛰️Request to the API (Local)", 
            color=reply_msg[2]))
        json_data = await fetch_data(data_file, strategy) # get data from the api 
        await reply_msg[0].edit(embed=create_embed(
            title=reply_msg[1], 
            description="📜 Save JSON Content, 📊 HTML Plot, and 🖼️ HTML Plot Image", 
            color=reply_msg[2]))
        temp_files = await save_json_and_image(json_data, data_file, strategy) # save json request data + HTML plot + HTML plot image
        await reply_msg[0].edit(embed=create_embed(
            title=reply_msg[1], 
            description="✅ Sending Data", 
            color=reply_msg[2]))
        await send_data_to_discord(message, json_data, temp_files, data_file, strategy) # send all the data, html plot code and html plot image on discord channel

    except requests.RequestException as e:
        await reply_embed(message, "❌ Error", f"Request failed: {e}", discord.Color.brand_red())
    except Exception as e:
        await reply_embed(message, "❌ Error", f"An unexpected error occurred: {e}", discord.Color.brand_red())

async def fetch_data(data_file, strategy):
    url = f"http://127.0.0.1:5000/QTSBE/{data_file}/{strategy}" # url of the request
    response = requests.get(url) # send the request to the api
    response.raise_for_status() # checkout of the request status
    return response.json() # request content from the api

async def save_json_and_image(json_data, data_file, strategy):
    temp_files = {} # here we create temp files to not save anything since its will be save on discord

    # wite json data to a temp file
    with tempfile.NamedTemporaryFile(delete=False, suffix='.json', mode='w', encoding='utf-8') as temp_file:
        json.dump(json_data, temp_file, indent=4)
        temp_files['json'] = temp_file.name

    fig = generate_plot_figure(json_data, data_file, strategy) # generate plot figure (chart), with indicators, etc
    os.makedirs('display/python/saved_results/', exist_ok=True) # spot where the code is saved (may we find a better a spot later)
    plot_html_filename = f'display/python/saved_results/{data_file}_{strategy}.html' # name file 
    fig.write_html(plot_html_filename) # write the html code generated by plotly
    temp_files['html'] = plot_html_filename # temp file here

    with tempfile.NamedTemporaryFile(delete=False, suffix='.png', mode='wb') as temp_image: # generate the image of the HTML plot in a temp file
        pio.write_image(fig, temp_image.name)
        temp_files['image'] = temp_image.name # stock the temp file name of the html plot img

    return temp_files # {json, html, image} temp files

async def send_data_to_discord(message, json_data, temp_files, data_file, strategy):
    drawdown_stats = json_data.get('stats', {}).get('drawdown:', {}) # data of drawdown from api request
    positions_stats = json_data.get('stats', {}).get('positions', {}) # data of positions from api request
    current_position_stat =  json_data.get('result', [])[2]

    embed = discord.Embed()

    # file objects discord for attachements
    file_json = discord.File(temp_files['json'], filename=f"{data_file}_{strategy}.json")
    file_html = discord.File(temp_files['html'], filename=f"{data_file}_{strategy}.html")
    file_image = discord.File(temp_files['image'], filename=f"{data_file}_{strategy}.png")

    embed.set_thumbnail(url="https://github.com/simonpotel/QTSBE/blob/7ab243450e7adc18367859638b40855139e437b4/files/logo.jpeg?raw=true")

    await send_stats_embed(message, drawdown_stats, positions_stats, current_position_stat) # create an embeds of the the content of drawdown/positions


    # reply to the original command message from the author with : 
    # - the embed with drawdown/positions stats
    # - full content of the api request in a json file
    # - a HTML code made by plotly to see the graphic with indicators and revelants ratios, etc
    # - image (a screen) of the html graphic generated before
    await message.reply(embed=embed, files=[file_json, file_html, file_image]) # send the reply message

    # delete every temp files
    for file_path in temp_files.values():
        os.remove(file_path) 

async def send_stats_embed(message, drawdown_stats, positions_stats, current_position_stat):
    embed = discord.Embed(
        title="Drawdown Stats",
        description="",
        color=discord.Color.green()
    )

    for key, value in drawdown_stats.items():
        if key == 'max_drawdown_period':
            value_str = f"{value[0]} to {value[1]}"
        else:
            value_str = f"{value:.4f}" if isinstance(value, (int, float)) else str(value)
        embed.add_field(name=key.replace('_', ' ').title(), value=value_str, inline=False)
    
    await message.reply(embed=embed)

    embed = discord.Embed(
        title="Positions Stats",
        description="",
        color=discord.Color.green()
    )

    for key, value in positions_stats.items():
        value_str = f"{value:.4f}" if isinstance(value, (int, float)) else str(value)
        if key in ['average_position_duration']:
            value_str = f"{value:.2f}"
        elif key in ['max_loss']:
            value_str = f"{value:.6f}"
        embed.add_field(name=key.replace('_', ' ').title(), value=value_str, inline=False)

    await message.reply(embed=embed)

    embed = discord.Embed(
        title="Current Position Stat",
        description="",
        color=discord.Color.green()
    )
    if isinstance(current_position_stat, list):
        for idx, position in enumerate(current_position_stat, 1):
            for key, value in position.items():
                embed.add_field(name=f"{key.replace('_', ' ').title()} {idx}", value=value, inline=False)
    else:
        for key, value in current_position_stat.items():
            embed.add_field(name=key.replace('_', ' ').title(), value=value, inline=False)
    
    await message.reply(embed=embed)

def generate_plot_figure(json_data, data_file, strategy):
    dates, opens, highs, lows, closes = extract_ohlc_data(json_data['data'])
    indicators = extract_indicators(json_data)
    trades = json_data['result'][1]
    trade_indices, trade_ratios = extract_trade_data(trades)
    rows = 1
    cols = 1

    # Determine plot layout based on indicators and trades
    if 'RSI' in indicators or 'Normalize_MACD' in indicators:
        price_row_height = 0.7
        rsi_row_height = 0.3
        rows += 1
    else:
        price_row_height = 1.0
        rsi_row_height = 0.0

    row_heights = [price_row_height]
    if 'RSI' in indicators or 'Normalize_MACD' in indicators:
        row_heights.append(rsi_row_height)

    if len(trade_ratios) > 0:
        cols += 1

    column_widths = [0.7] * cols
    if cols > 1:
        column_widths[0] = 0.7

    # Create subplot figure
    fig = make_subplots(rows=rows, cols=cols, shared_xaxes=True, vertical_spacing=0.25,
                        row_heights=row_heights, column_widths=column_widths)

    # Candlestick plot (main OHLC)
    fig.add_trace(go.Candlestick(x=dates, open=opens, high=highs, low=lows, close=closes), row=1, col=1)

    # Add other plots for indicators
    for indicator in indicators:
        row = 1
        if indicator == 'RSI' or indicator == 'Normalize_MACD':
            row += 1
        fig.add_trace(go.Scatter(x=dates, y=indicators[indicator], mode='lines', name=indicator,
                                 line=dict(color=chart_colors[indicator])), row=row, col=1)

    # Add trades plot if there are trade ratios
    if len(trade_ratios) > 0:
        fig.add_trace(go.Scatter(x=trade_indices, y=trade_ratios, mode='lines', name='Trade Ratios',
                                 line=dict(color=chart_colors['Test'])), row=1, col=2)
        cumulative_ratios = [float(cumulative_ratio) for cumulative_ratio in json_data["stats"]["positions"]["cumulative_ratios"]]
        fig.add_trace(go.Scatter(x=trade_indices, y=cumulative_ratios, mode='lines', name='Cumulative Ratios',
                                 line=dict(color=chart_colors['MA_100'])), row=1, col=2)

    # Plot buy and sell markers
    buy_dates = [trade['buy_date'] for trade in trades]
    buy_prices = [trade['buy_price'] for trade in trades]
    buy_indices = [trade['buy_index'] for trade in trades]
    buy_signals = [trade['buy_signals']['Buy_Signal'] for trade in trades]

    sell_dates = [trade['sell_date'] for trade in trades]
    sell_prices = [trade['sell_price'] for trade in trades]
    sell_indices = [trade['sell_index'] for trade in trades]
    sell_signals = [trade['sell_signals']['Sell_Signal'] for trade in trades]

    ratios = [float(ratio) for ratio in json_data["stats"]["positions"]["all_ratios"]]

    # Hover texts for buy and sell markers
    buy_hover_texts = [f"Index: {index}<br>Price: {price}<br>Date: {date}<br>Buy Signal: {buy_signal}" for index, price, date, buy_signal in zip(buy_indices, buy_prices, buy_dates, buy_signals)]
    sell_hover_texts = [f"Index: {index}<br>Price: {price}<br>Date: {date}<br>Ratio: {ratio}<br>Sell Signal: {sell_signal}" for index, price, date, ratio, sell_signal in zip(sell_indices, sell_prices, sell_dates, ratios, sell_signals)]

    # Plot buy and sell markers
    fig.add_trace(go.Scatter(
        x=buy_dates,
        y=buy_prices,
        mode='markers',
        name='Buy',
        marker=dict(symbol='triangle-up', color='#B0FE76', size=10),
        hovertext=buy_hover_texts,
        hoverinfo='text'
    ), row=1, col=1)
    fig.add_trace(go.Scatter(
        x=sell_dates,
        y=sell_prices,
        mode='markers',
        name='Sell',
        marker=dict(symbol='triangle-down', color='#2DC7FF', size=10),
        hovertext=sell_hover_texts,
        hoverinfo='text'
    ), row=1, col=1)

    # Update layout settings
    fig.update_layout(
        title=f"{data_file} ({strategy})",
        xaxis_title='Date',
        yaxis_title='Price',
        xaxis_rangeslider_visible=False,
        plot_bgcolor='#161a25',
        paper_bgcolor='#161a25',
        font=dict(color='white'),
        yaxis=dict(gridcolor='#6c7386'),
        xaxis=dict(gridcolor='#6c7386'),
        yaxis2=dict(gridcolor='#6c7386'),
        xaxis2=dict(gridcolor='#6c7386')
    )

    # Adjust plot size for RSI/Normalize_MACD if they exist
    if 'RSI' in indicators or 'Normalize_MACD' in indicators:
        fig.update_yaxes(range=[0, 100], row=2, col=1)
        fig.add_shape(type="line", x0=min(dates), y0=50, x1=max(dates), y1=50, row=2, col=1, line=dict(color="LightSkyBlue", width=3))

    return fig

def extract_ohlc_data(data):
    dates, opens, highs, lows, closes, volume = zip(*data)
    return dates, opens, highs, lows, closes

def extract_indicators(json_data):
    indicators = {}
    for indicator in json_data['result'][0]:
        indicators[indicator] = json_data['result'][0][indicator]
    return indicators

def extract_trade_data(trades):
    trade_indices = list(range(1, len(trades) + 1))
    trade_ratios = [trade['ratio'] for trade in trades if 'ratio' in trade]
    return trade_indices, trade_ratios

async def analyse(client, message, args):
    """
    Function toggeled when the command is used
    """
    if len(args) < 2:
        await reply_embed(message, "❌ Error", "You need to provide both the data and strategy arguments.", discord.Color.brand_red())
        return

    data = args[0]
    strategy = args[1]
    await fetch_and_send_data(message, data, strategy)
